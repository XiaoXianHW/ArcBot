diff --git a/LLMChat/llm_api.py b/LLMChat/llm_api.py
index a685c09..f50f959 100644
--- a/LLMChat/llm_api.py
+++ b/LLMChat/llm_api.py
@@ -26,36 +26,43 @@ def get_ai_response(conversation):
 
     buffer = ""
     for line in response.iter_lines(decode_unicode=True):
-        if not line or not line.strip():
-            continue
-        # 去除前缀 "data:" 和两端空白
+        line = line.strip() # 先去除两端空白
+        if not line:
+            continue # 跳过空行
+
+        # 严格检查是否为 SSE 数据或结束标记
         if line.startswith("data:"):
-            line = line[len("data:"):].strip()
-        # 检查是否为结束标志
-        if line == "[DONE]":
-            break
-        try:
-            data = json.loads(line)
-            if CONFIG["debug"]: print(repr(line))
-        except Exception as e:
-            print("解析流式响应出错:", e, "line内容:", repr(line))
-            continue
+            line_data = line[len("data:"):].strip()
+            if line_data == "[DONE]":
+                break # 正常结束
+            try:
+                data = json.loads(line_data)
+                if CONFIG["debug"]: print(f"[DEBUG] Stream Data: {repr(line_data)}")
+            except json.JSONDecodeError as e:
+                # 仅记录 JSON 解析错误，忽略非 JSON 行
+                print(f"解析流式 JSON 响应出错: {e}, line内容: {repr(line_data)}")
+                continue
+            except Exception as e:
+                print(f"处理流式响应时发生未知错误: {e}, line内容: {repr(line_data)}")
+                continue
+            
+            # 提取内容
+            delta = data.get("choices", [{}])[0].get("delta", {}).get("content", "")
+            if delta:
+                delta = delta.replace("\r\n", "\n")
+                buffer += delta
+                while "[send]" in buffer or (buffer.endswith("\n") and "\n" in buffer):
+                    if "[send]" in buffer:
+                        part, buffer = buffer.split("[send]", 1)
+                    else:
+                        part, buffer = buffer.split("\n", 1)
+                    part = part.strip()
+                    if part:
+                        yield part
+        elif line == "[DONE]":
+             break
 
-        delta = data.get("choices", [{}])[0].get("delta", {}).get("content", "")
-        if delta:
-            # 统一替换换行符格式
-            delta = delta.replace("\r\n", "\n")
-            buffer += delta
-            # 当 buffer 中包含 "[send]" 或以换行符结束时进行分段输出
-            while "[send]" in buffer or (buffer.endswith("\n") and "\n" in buffer):
-                if "[send]" in buffer:
-                    part, buffer = buffer.split("[send]", 1)
-                else:
-                    part, buffer = buffer.split("\n", 1)
-                part = part.strip()
-                if part:
-                    yield part
-    # 输出剩余内容（如果 buffer 中仍有内容）
+    # 输出剩余内容
     if buffer.strip():
         yield buffer.strip()
 
@@ -68,17 +75,31 @@ def get_ai_response_with_image(conversation, image=None, image_type="url"):
     api_url = CONFIG['image_ai']['api_url']
     token = CONFIG['image_ai']['token']
     model = CONFIG['image_ai']['model']
+    print(f"[DEBUG] get_ai_response_with_image: Using API URL='{api_url}', Model='{model}'")
+
     # 自动处理本地图片为base64
+    original_image_type = image_type
     if image_type == "file" and image:
-        with open(image, "rb") as f:
-            image = base64.b64encode(f.read()).decode()
-        image_type = "base64"
+        print(f"[DEBUG] get_ai_response_with_image: Converting file to base64: '{image}'")
+        try:
+            with open(image, "rb") as f:
+                image = base64.b64encode(f.read()).decode()
+            image_type = "base64"
+            print("[DEBUG] get_ai_response_with_image: File converted to base64 successfully.")
+        except Exception as e:
+             print(f"[ERROR] get_ai_response_with_image: Failed to read or encode file: {e}")
+             raise Exception(f"处理本地图片文件失败: {e}")
+
+    print(f"[DEBUG] get_ai_response_with_image: Final image_type='{image_type}'")
+
     # 判断是否为阿里云DashScope
     if "dashscope.aliyuncs.com" in api_url:
         try:
             import dashscope
         except ImportError:
-            raise Exception("未检测到dashscope库，请先安装：pip install dashscope")
+             print("[ERROR] DashScope library not found. Please install with: pip install dashscope")
+             raise Exception("未检测到dashscope库，请先安装：pip install dashscope")
+        
         dashscope.api_key = token
         messages = []
         for msg in conversation:
@@ -96,16 +117,22 @@ def get_ai_response_with_image(conversation, image=None, image_type="url"):
                 messages.append({"role": msg["role"], "content": content})
             else:
                 messages.append(msg)
+        print(f"[DEBUG] DashScope Request: model='{model}', messages_structure={[m['role'] for m in messages]}")
         try:
             response = dashscope.MultiModalConversation.call(
                 model=model,
                 messages=messages
             )
+            print(f"[DEBUG] DashScope Response Status: {response.status_code}")
             if response.status_code == 200:
-                return response.output.choices[0].message.content
+                content = response.output.choices[0].message.content
+                print(f"[DEBUG] DashScope Response Success, content='{content[:100]}...'")
+                return content
             else:
+                print(f"[ERROR] DashScope API Call Failed: Code={response.code}, Message={response.message}")
                 raise Exception(f"调用失败: {response.code}, {response.message}")
         except Exception as e:
+            print(f"[ERROR] Calling DashScope API failed: {str(e)}")
             raise Exception(f"调用DashScope API失败: {str(e)}")
     else:
         # OpenAI兼容HTTP请求
@@ -129,6 +156,7 @@ def get_ai_response_with_image(conversation, image=None, image_type="url"):
                     messages[-1]["content"] = [image_obj]
             else:
                 messages.append({"role": "user", "content": [image_obj]})
+        print(f"[DEBUG] OpenAI-Compat Request: url='{api_url}', model='{model}', messages_structure={[m['role'] for m in messages]}")
         payload = {
             "model": model,
             "messages": messages,
@@ -136,10 +164,14 @@ def get_ai_response_with_image(conversation, image=None, image_type="url"):
         }
         try:
             response = requests.post(api_url, headers=headers, json=payload)
+            print(f"[DEBUG] OpenAI-Compat Response Status: {response.status_code}")
             if response.status_code != 200:
-                raise Exception(f"AI接口调用失败, 状态码：{response.status_code}, {response.text}")
+                 print(f"[ERROR] OpenAI-Compat API Call Failed: Status={response.status_code}, Response Text='{response.text}'")
+                 raise Exception(f"AI接口调用失败, 状态码：{response.status_code}, {response.text}")
             data = response.json()
             content = data.get("choices", [{}])[0].get("message", {}).get("content", "")
+            print(f"[DEBUG] OpenAI-Compat Response Success, content='{content[:100]}...'")
             return content
         except Exception as e:
+            print(f"[ERROR] Calling OpenAI-Compat API failed: {str(e)}")
             raise Exception(f"调用OpenAI兼容API失败: {str(e)}") 
\ No newline at end of file
diff --git a/LLMChat/utils/message_content.py b/LLMChat/utils/message_content.py
index fdd7d4d..c56c18e 100644
--- a/LLMChat/utils/message_content.py
+++ b/LLMChat/utils/message_content.py
@@ -13,6 +13,7 @@ def describe_image(image_source: str, image_type: str = "url") -> str:
     """
     识图接口：根据图片来源(URL或路径)返回描述。
     """
+    print(f"[DEBUG] describe_image: source='{image_source}', type='{image_type}'")
     prompt_path = os.path.join(os.path.dirname(__file__), '../config/image_system_prompt.txt')
     try:
         with open(prompt_path, 'r', encoding='utf-8') as f:
@@ -26,9 +27,10 @@ def describe_image(image_source: str, image_type: str = "url") -> str:
     ]
     try:
         desc = get_ai_response_with_image(conversation, image=image_source, image_type=image_type)
+        print(f"[DEBUG] describe_image: Success, desc='{desc[:100]}...' ")
         return f"[图片内容描述: {desc.strip()}]"
     except Exception as e:
-        # 返回包含具体错误信息的字符串
+        print(f"[ERROR] describe_image: Failed, error='{str(e)}'")
         return f"[图片内容描述获取失败: {str(e)}]"
 
 def get_mface_description(mface_data: dict) -> str:
@@ -59,6 +61,7 @@ def parse_group_message_content(msg_dict: Dict[str, Any]) -> str:
         seg_type = seg.get("type")
         data = seg.get("data", {})
         temp_file_path = None # 当前循环的临时文件路径
+        print(f"[DEBUG] parse_group_message: Found {seg_type}, data='{data}'")
 
         try:
             if seg_type == "text":
@@ -66,15 +69,18 @@ def parse_group_message_content(msg_dict: Dict[str, Any]) -> str:
             elif seg_type == "image" or seg_type == "mface":
                 image_source_path = None
                 is_temp_file = False
+                file_path = data.get("file")
+                url = data.get("url")
+                print(f"[DEBUG] parse_group_message: Found {seg_type}, file='{file_path}', url='{url}'")
 
                 # 1. 优先尝试 file 字段
-                file_path = data.get("file")
-                if file_path and os.path.exists(file_path): # 简单检查路径是否存在
+                if file_path and os.path.exists(file_path):
                     image_source_path = file_path
+                    print(f"[DEBUG] parse_group_message: Using local file path: {image_source_path}")
                 else:
                     # 2. file 无效，尝试 url 下载
-                    url = data.get("url")
                     if url:
+                        print(f"[DEBUG] parse_group_message: File path invalid or missing, attempting download from URL: {url}")
                         try:
                             response = requests.get(url, stream=True, timeout=10) # 增加超时
                             response.raise_for_status() # 检查HTTP错误
@@ -86,6 +92,7 @@ def parse_group_message_content(msg_dict: Dict[str, Any]) -> str:
                                 temp_files_to_delete.append(temp_file_path) # 加入待删除列表
                                 image_source_path = temp_file_path
                                 is_temp_file = True
+                                print(f"[DEBUG] parse_group_message: Downloaded to temporary file: {image_source_path}")
                         except requests.exceptions.RequestException as req_e:
                             print(f"下载图片URL失败: {url}, Error: {req_e}")
                         except IOError as io_e:
